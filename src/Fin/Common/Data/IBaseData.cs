using System;
using System.IO;

namespace QuantConnect.Data
{
    /// <summary>
    /// Base Data Class: Type, Timestamp, Key -- Base Features.
    /// </summary>
    public interface IBaseData
    {
        /// <summary>
        /// Market Data Type of this data - does it come in individual price packets or is it grouped into OHLC.
        /// </summary>
        MarketDataType DataType
        {
            get;
            set;
        }
        
        /// <summary>
        /// Time keeper of data -- all data is timeseries based.
        /// </summary>
        DateTime Time
        {
            get;
            set;
        }

        /// <summary>
        /// End time of data
        /// </summary>
        DateTime EndTime
        {
            get;
            set;
        }
        
        
        /// <summary>
        /// Symbol for underlying Security
        /// </summary>
        Symbol Symbol
        {
            get;
            set;
        }


        /// <summary>
        /// All timeseries data is a time-value pair:
        /// </summary>
        decimal Value
        {
            get;
            set;
        }


        /// <summary>
        /// Alias of Value.
        /// </summary>
        decimal Price
        {
            get;
        }

        /// <summary>
        /// Reader Method :: using set of arguements we specify read out type. Enumerate
        /// until the end of the data stream or file. E.g. Read CSV file line by line and convert
        /// into data types.
        /// </summary>
        /// <returns>BaseData type set by Subscription Method.</returns>
        [Obsolete("Reader(SubscriptionDataConfig, string, DateTime, DataFeedEndpoint) method has been made obsolete, use Reader(SubscriptionDataConfig, string, DateTime, bool) instead.")]

        BaseData Reader(SubscriptionDataConfig config, string line, DateTime date, DataFeedEndpoint dataFeed);

        /// <summary>
        /// Reader converts each line of the data source into BaseData objects. Each data type creates its own factory method, and returns a new instance of the object
        /// each time it is called. The returned object is assumed to be time stamped in the config.ExchangeTimeZone.
        /// </summary>
        /// <param name="config">Subscription data config setup object</param>
        /// <param name="line">Line of the source document</param>
        /// <param name="date">Date of the requested data</param>
        /// <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
        /// <returns>Instance of the T:BaseData object generated by this line of the CSV</returns>
        BaseData Reader(SubscriptionDataConfig config, string line, DateTime date, bool isLiveMode);

        /// <summary>
        /// Reader converts each line of the data source into BaseData objects. Each data type creates its own factory method, and returns a new instance of the object
        /// each time it is called. The returned object is assumed to be time stamped in the config.ExchangeTimeZone.
        /// </summary>
        /// <param name="config">Subscription data config setup object</param>
        /// <param name="stream">The data stream</param>
        /// <param name="date">Date of the requested data</param>
        /// <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
        /// <returns>Instance of the T:BaseData object generated by this line of the CSV</returns>
        BaseData Reader(SubscriptionDataConfig config, StreamReader stream, DateTime date, bool isLiveMode);

        /// <summary>
        /// Return the URL string source of the file. This will be converted to a stream 
        /// </summary>
        /// <param name="datafeed">Type of datafeed we're reqesting - backtest or live</param>
        /// <param name="config">Configuration object</param>
        /// <param name="date">Date of this source file</param>
        /// <returns>String URL of source file.</returns>
        string GetSource(SubscriptionDataConfig config, DateTime date, DataFeedEndpoint datafeed);

        /// <summary>
        /// Indicates if there is support for mapping
        /// </summary>
        /// <returns>True indicates mapping should be used</returns>
        bool RequiresMapping();

        /// <summary>
        /// Return a new instance clone of this object
        /// </summary>
        /// <returns></returns>
        BaseData Clone();

    } // End Base Data Class

} // End QC Namespace
