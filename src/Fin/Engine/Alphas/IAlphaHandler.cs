using System.ComponentModel.Composition;
using QuantConnect.Interfaces;
using QuantConnect.Lean.Engine.TransactionHandlers;
using QuantConnect.Packets;
using QuantConnect.Parameters;

namespace QuantConnect.Lean.Engine.Alpha
{
    /// <summary>
    /// Alpha handler defines how to process insights generated by an algorithm
    /// </summary>
    [InheritedExport(typeof(IAlphaHandler))]
    public interface IAlphaHandler
    {
        // SqCore Change NEW:
        SqBacktestConfig SqBacktestConfig
        {
            get;
            set;
        }
        // SqCore Change END

        /// <summary>
        /// Gets a flag indicating if this handler's thread is still running and processing messages
        /// </summary>
        bool IsActive { get; }

        /// <summary>
        /// Gets the current alpha runtime statistics
        /// </summary>
        AlphaRuntimeStatistics RuntimeStatistics { get; }

        /// <summary>
        /// Initializes this alpha handler to accept insights from the specified algorithm
        /// </summary>
        /// <param name="job">The algorithm job</param>
        /// <param name="algorithm">The algorithm instance</param>
        /// <param name="messagingHandler">Handler used for sending insights</param>
        /// <param name="api">Api instance</param>
        /// <param name="transactionHandler">Algorithms transaction handler</param>
        void Initialize(AlgorithmNodePacket job, IAlgorithm algorithm, IMessagingHandler messagingHandler, IApi api, ITransactionHandler transactionHandler);

        /// <summary>
        /// Invoked after the algorithm's Initialize method was called allowing the alpha handler to check
        /// other things, such as sampling period for backtests
        /// </summary>
        /// <param name="algorithm">The algorithm instance</param>
        void OnAfterAlgorithmInitialized(IAlgorithm algorithm);

        /// <summary>
        /// Performs processing in sync with the algorithm's time loop to provide consisten reading of data
        /// </summary>
        void ProcessSynchronousEvents();

        /// <summary>
        /// Stops processing in the <see cref="Engine.Run"/> method
        /// </summary>
        void Exit();
    }
}
